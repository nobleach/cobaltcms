// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package storage

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	types "github.com/nobleach/cobaltcms/internal/types"
)

const getPublishedContentById = `-- name: GetPublishedContentById :many
SELECT c.id, c.content_type, c.name, c.body, c.extended_attributes
FROM contents_contents cc
LEFT JOIN contents c
ON cc.content_id = c.id
WHERE cc.page_content_id = $1
AND c.published_status = 'PUBLISHED'
OR c.published_status = 'SCHEDULED'
AND  c.publish_end >= TO_TIMESTAMP($2, 'YYYY-MM-DD HH24:MI:ss')
AND  c.publish_start <=  TO_TIMESTAMP($2, 'YYYY-MM-DD HH24:MI:ss')
`

type GetPublishedContentByIdParams struct {
	PageContentID uuid.UUID
	ToTimestamp   string
}

type GetPublishedContentByIdRow struct {
	ID                 uuid.NullUUID
	ContentType        pgtype.Text
	Name               pgtype.Text
	Body               types.JSONB
	ExtendedAttributes types.JSONB
}

func (q *Queries) GetPublishedContentById(ctx context.Context, arg GetPublishedContentByIdParams) ([]GetPublishedContentByIdRow, error) {
	rows, err := q.db.Query(ctx, getPublishedContentById, arg.PageContentID, arg.ToTimestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublishedContentByIdRow
	for rows.Next() {
		var i GetPublishedContentByIdRow
		if err := rows.Scan(
			&i.ID,
			&i.ContentType,
			&i.Name,
			&i.Body,
			&i.ExtendedAttributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllPublishedStatuses = `-- name: ListAllPublishedStatuses :many
SELECT id, status
FROM published_statuses
`

type ListAllPublishedStatusesRow struct {
	ID     uuid.UUID
	Status string
}

func (q *Queries) ListAllPublishedStatuses(ctx context.Context) ([]ListAllPublishedStatusesRow, error) {
	rows, err := q.db.Query(ctx, listAllPublishedStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllPublishedStatusesRow
	for rows.Next() {
		var i ListAllPublishedStatusesRow
		if err := rows.Scan(&i.ID, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedContentForDateTime = `-- name: ListPublishedContentForDateTime :many
SELECT id, content_type, name, body, extended_attributes 
FROM contents
WHERE published_status = 'PUBLISHED'
OR published_status = 'SCHEDULED'
AND  publish_end >= TO_TIMESTAMP($1, 'YYYY-MM-DD HH24:MI:ss')
AND  publish_start <=  TO_TIMESTAMP($1, 'YYYY-MM-DD HH24:MI:ss')
`

type ListPublishedContentForDateTimeRow struct {
	ID                 uuid.UUID
	ContentType        string
	Name               string
	Body               types.JSONB
	ExtendedAttributes types.JSONB
}

func (q *Queries) ListPublishedContentForDateTime(ctx context.Context, toTimestamp string) ([]ListPublishedContentForDateTimeRow, error) {
	rows, err := q.db.Query(ctx, listPublishedContentForDateTime, toTimestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPublishedContentForDateTimeRow
	for rows.Next() {
		var i ListPublishedContentForDateTimeRow
		if err := rows.Scan(
			&i.ID,
			&i.ContentType,
			&i.Name,
			&i.Body,
			&i.ExtendedAttributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
